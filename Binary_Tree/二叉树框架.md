# 二叉树框架使用步骤：

## 1. **分析问题**：
先分析问题，把问题抽象为二叉树

## 2. **明确思路**：
   1. ***分析时候需要子树来解决问题***  
如需要，则一般是后序遍历；如不需要，一般对前后序不敏感。

   - 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「***遍历***」的思维模式。
   - 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「***分解问题***」的思维模式。

   2. ***无论使用哪种思维模式，你都需要思考：***  
   - 如果单独抽出一个二叉树节点，它需要做什么事情？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。
   - 需要在什么时候（前/中/后序位置）做？

## 3. **框架**：
```
void traverse(TreeNode node) {
    // 处理 终止情况(前序遍历) / 初始情况(后序遍历) 
    // 不要改这部分代码。下面前/中/后序的代码都是从叶子结点开始执行。
    if (node == null) {
        return;
    }
    
    // 前序位置
    traverse(node.left);
    // 中序位置
    traverse(node.right);
    // 后序位置
}
```

### ！！注意：
1. 这是前序遍历常用的框架。后序遍历要：
   - 重新***定义traverse函数***，以符合子问题的定义
   - 定义***函数返回值***，让父节点获得子树的信息。

2. 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。  
如果在分析问题的过程中发现需要***子树的信息***才能解决问题，那么大概率要给函数设置合理的定义和返回值，在后序位置写代码了。  

3. 构建二叉树框架：前序遍历（见654，105）  
   生成二叉树只能用前序遍历处理每个节点。如果要是根据后序遍历结果生成二叉树，就可以从后向前处理后序遍历结果，即root+右子树+左子树，这样就可以使用二叉树构建框架（前序遍历）生成二叉树。（见297）
    ```
    public TreeNode build(int[] nums, int low, int high) {
        // 终止条件（此时已构建完叶子结点）
        if(low > high) return null;

        // 前序操作
        ......
        TreeNode node = new TreeNode(value);

        // 遍历
        node.left = build(nums, low, mid-1);
        node.right = build(nums, mid+1, high);

        return node;
    }
    ```

4. 二叉搜索树（BST）常用中序遍历：  
   - 正序的中序遍历得到从小到大的遍历结果（遍历顺序：左-中-右）
   - 倒序的中序遍历得到从大到小的遍历结果（遍历顺序：右-中-左）

