# 子序列问题
## 描述：
题目给1个或2个string，让你求满足要求的最长子序列/连续子数组。  
（子序列不是子串，可以不连续，但元素的相对位置顺序不能变）  

## 常见题型：
- 最长递增子序列【LIS算法】
- 最大子数组
- 编辑距离
- 最长公共子序列 = 使两个字符串相同的最小删除数 = 最小 ASCII 删除和
- ⚠️注意问题变形

## 如果题目只给了 1个 String【一维dp数组】：
### 1. 子问题（状态）& dp数组定义：
由于采用自底向上的写法，子问题 和 dp数组定义 实际上是一回事。  
- 子问题（状态）：指针 i  
- dp数组定义：  
  - 在 arr[ 0..i ] 中，符合要求的最长子序列的长度是 dp[ i ]  
  - 在 arr[ 0..i ] 中，符合要求的最长子序列的长度是 dp[ i ]，子序列必须以 i 指向的内容结尾  
  - （个别问题需要两个指针，如：最长回文子序列，其实属于下文 二维dp数组 的解法）

### 2. 选项（选择）& 状态转移：
无定式。  
以最长递增子序列为例：详见 300 题。  
```
for (int i = 1; i < n; i++) {
    // 我们只要找到前面那些结尾比 nums[i] 小的子序列，然后把 nums[i] 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。
    // 故在满足nums[i-1]<nums[i]的条件下，只需要在dp[1...i-1]中找到最大值即可。
    for (int j = 0; j < i; ¡++) {
        dp[i] = 最值(dp[i], dp[j] + ...);
    }
}
```

### 3. base case
应为最小子问题，一般是dp[ 0 ]，但需结合题意。  

### 4. Return
需要看 dp 数组定义：
- 在 arr[ 0..i ] 中，符合要求的最长子序列的长度是 dp[ i ]：return 最大子问题对应的dp数组元素即可。
- 在 arr[ 0..i ] 中，符合要求的最长子序列的长度是 dp[ i ]，子序列必须以 i 指向的内容结尾：需遍历dp数组，找最值返回。


## 如果题目给了 2个 String【二维dp数组】：
### 1. 子问题（状态）& dp数组定义：
由于采用自底向上的写法，子问题 和 dp数组定义 实际上是一回事。
- 子问题（状态）：指针 i 和 指针 j 的组合
- dp数组定义：
    - 题目给了 2个 String: 在 arr1[ 0..i ] 和 arr2 [ 0..j ] 中，符合要求的子序列长度为 dp[ i ][ j ]  
    - 题目给了 1个 String: 在 arr[ i..j ] 中，符合要求的子序列的长度为 dp[ i ][ j ]  (最长回文子序列)  

### 2. 选项（选择）& 状态转移：
只思考当前指针 i 和 j 指向的这2个元素 有哪些选项即可，无需思考整个子序列。  
**i 和 j 指向的元素有哪些选项？**  需穷举出所有选项，让最值去自动选择一个选项！    
这些选项的本质？***要不要指针指向的元素***
- i 和 j 指向的元素相等：
  - i 和 j 指向的元素都保留在最长子序列中（都要）  
- i 和 j 指向的元素不相等：  
  - i 指向的元素保留在最长子序列中，j 不保留（要1个）  
  - j 指向的元素保留在最长子序列中，i 不保留（要1个）  
  - 都不保留（不要）

```
for (int i = 0; i < n; i++）{
    for (int j = 0; j < n; j++) {
        if (arr[i] == arr[j])
            dp[i][j] = dp[i-1][j-1] + ... ;
        else
            dp[i][j] = 最值(dp[i][j-1] + ... , dp[i-1][j] + ... , dp[i-1][j-1] + ... );
            // 这里等号右边的状态可以视为当前状态，等号左边的可以视为下一个状态，
            // 如 dp[i][j-1] 状态转移成 dp[i][j]，就代表 i 指向的元素保留在最长子序列中，j 不保留。
    }
}
```

### 3. base case
应为最小子问题，一般是第一行和第一列，也有可能是对角线，需结合题意。  
**方法：**  
1. 画出二维矩阵，结合题意尝试给第一行和第一列赋予实际含义，看他们是否真的是 最小子问题。（对角线同理）  
2. 把任一个字符串缩到只有 0个 字符，看 最小子问题 是什么。
3. base case 的取值结合在题中的实际含义。一般是某一状态的取值为 0 时，根据其余状态不同的取值，决定对应的 base case的取值。

### 4. Return
return 最大子问题对应的dp数组元素即可。