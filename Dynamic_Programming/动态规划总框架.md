# 动态规划总框架

## 1. 识别题目
### 1.1 题型：有选项的求最值题
思路上需要满足从子问题推出原问题

### 1.2 特点：
- 重叠子问题：从状态A到状态B，有多种路径 (即调用不同的递归都可以从A到B)
- 最优子结构：子问题间必须互相独立，不存在相互制约
  - 从最简单的 base case 往后推导，链式反应


## 2. 解题
本质：穷举 所有子问题和选项

### 2.1 解题步骤：
1. 明确 「**单位子问题**」（**状态**：什么量会变？）  
2. 明确 「**dp 函数/数组的定义**」：要结合题目
3. 明确「**选项**」（**选择**：导致状态变化的动作有哪些？也可以想一想是个什么样的多叉树？）
4. 列出状态转移方程（状态转移方程直接代表着暴力解法）  
     **数学归纳法**：根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。  
     > 但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。
5. 明确 「Base Case」  
（最小的子问题是由base case算出来的，base case是算法运行的起点。想一想算法要运行，初始就应该知道什么？）

### 2.2 总框架
#### 框架在做什么：
1. 初始化 **Base Case**
2. **穷举所有子问题的组合**
3. 对每个子问题的组合，穷举所有的选项，做**求最值**的选择操作

#### 总框架：
1. 自底向上:
```
int[][] dp = new int dp[][];

// 1. 初始化 base case
dp[0][...] = ... ;
dp[...][0] = ... ;

// 2. 穷举所有子问题的组合
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        // 3. 选择
        dp[状态1][状态2] = 求最值(选择1，选择2...)；

return ... ;
```

2. 自顶向下: 【还需包含备忘录初始值、索引合法性检查】
```
// 备忘录
memo = [][]... / HashMap<>();

返回值 dp(题目给出的数据结构, 状态1, 状态2 ... ) {
    // 1. base case
    if( ... ) return ...;

     // 4. 查询备忘录，看这个子问题是否已经计算过了
    if(memo[][]... != -666) return memo[][]...;

    // 2. 穷举所有子问题的组合
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
        // 3. 选择
        result = 求最值(result, dp(状态1, 状态2, ...))
        
        // 4. 写入备忘录
        // memo[][]... = result;
    
    // 4. (也可能在for外)写入备忘录
    memo[][]... = result;
    return result;
}

```

⚠️注意：
1. 当题目比较复杂，如：状态转移中，等号左侧的状态 和 等号右边的状态 在dp数组中不连着时；可能出现特殊情况、特殊边界较多，难以处理时，  
   应考虑使用「**自顶向下**」的写法，  
   因为「自底向上」处理**索引越界、特殊情况、特殊边界**时 都需要在 for 循环中处理，而「自顶向下」可以用 if **单独处理**。  

### 2.3 问题：

#### 2.3.1 确定 base case 的方法：
1. 画出二维矩阵，结合题意尝试给第一行和第一列赋予实际含义，看他们是否真的是 最小子问题。（对角线同理）
2. 把任一个状态的 大小 / 取值 变成 0，看 最小子问题 是什么。
3. base case 的取值结合在题中的实际含义。一般是某一状态的取值为 0 时，根据其余状态不同的取值，决定对应的 base case的取值。


#### 2.3.2 dp 数组的遍历方向：
只要把住两点就行了：  
1、遍历的过程中，所需的状态必须是已经计算出来的。  
2、遍历结束后，存储结果的那个位置必须已经被计算出来。  
> 主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案。  

例：假设 base case 是对角线，最终结果是 dp[0][n-1]  
<img src="https://labuladong.github.io/algo/images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/4.jpg" width="40%" height="auto">  
<img src="https://labuladong.github.io/algo/images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/5.jpg" width="40%" height="auto">

详见：[labuladong -> dp 数组的遍历方向](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/zui-you-zi-fbef6/#%E5%9B%9B%E3%80%81dp-%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%90%91)

#### 2.3.3 自顶向下写法的备忘录初始值
***自顶向下***：  
**备忘录初始值** 和 **索引合法性检查** 都需要返回一个返回一个不可能被取到的值，  
即（需要结合题目算一下）dp数组的取值范围 [a,b] 之外的值，  
且求最小值要返回比 b 大值，求最大值要返回比 a 小值。  
详见：[base case 和备忘录的初始值怎么定？](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/basecase-h-de925/)  

> ⚠️注意：这里的"备忘录"指的是自顶向下的写法。自顶向下的备忘录在使用前需要判断是否被修改过，所以需要初始化成一个不可能被取到的无意义的值。  
自底向上由于直接使用 dp 数组，使用前不判断是否被修改过，所以初始值要结合题意取一个有意义的值。  
自底向上通常不需要写索引合法性检查，for 循环会控制索引合法。  
