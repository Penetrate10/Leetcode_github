# 背包问题
## 描述：
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有自己的属性：重量 + 价值 / ... / null 。

## 常见题型：
- [0-1 背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c/)：每个物品有重量和价值两个属性。现在让你用这个背包装物品，最多能装的价值是多少？
- [子集背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--43be3/)：给一个可装载重量为 **W/2** 的背包和 N 个物品。每个物品的只有重量属性。现在让你装物品，是否存在一种装法，能够恰好将背包装满？【416题】
- [完全背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--70de0/)：每个物品的只有重量属性。每个物品的**数量无限**。问有多少种方法，能够把背包恰好装满？【518题】
- ⚠️注意问题变形

## 思路：
以 0-1 背包问题为例

### 1. 子问题（状态）& dp数组定义：
由于采用自底向上的写法，子问题 和 dp数组定义 实际上是一回事。

- 子问题（状态）：「背包的容量」i 和「可选择的物品」j 的所有组合。
- dp数组定义：对于前 `i` 个物品，当前背包的容量为 `w`，这种情况下可以装的最大价值是 `dp[i][w]`。（不强制包含第i个物品）
  - 比如说，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

### 2. 选项（选择）& 状态转移：
对于每件物品，选项就是「**把物品 `i` 装进背包**」或者「**不把物品 `i` 装进背包**」嘛。 然后让最值去自动选择一个选项！    
这些选项的本质？***要不要指针指向的物品***

- 如果不把第 `i` 个物品装入背包，那么最大价值 `dp[i][w]` 应该等于 `dp[i-1][w]`，继承之前的结果。
- 如果把第 `i` 个物品装入了背包，那么 `dp[i][w]` 应该等于 `val[i-1] + dp[i-1][w - wt[i-1]]`。
  - 选择将第 `i` 个物品装进背包，那么第 `i` 个物品的价值 `val[i-1]` 肯定就到手了，接下来你就要在剩余容量 `w - wt[i-1]` 的限制下，在前 `i - 1` 个物品中挑选，即 `dp[i-1][w - wt[i-1]]`。

> val[ i-1 ]的 i-1 是索引偏移，这是因为 dp[ 1 ] 对应的才是 wt[ 0 ] 。

0-1 背包框架：
```
int[][] dp = new int[N+1][W+1]；
/* 1. 初始化 base case */
dp[0][..] = ...；
dp[..][0] = ...；

/* 2. 穷举所有子问题的组合 */
for i in [1..N] {
    for w in [1..W] {
        /* 3. 选择 */
        dp[i][w] = max(
            dp[i-1][w],                      // 不把物品 i 装进背包
            dp[i-1][w - wt[i-1]] + val[i-1]  // 把物品 i 装进背包
        )；
    }
}

return dp[N][W]；
```

⚠️注意：不同问题的状态转移和选项有所不同：
- 0-1 背包是求最值
- 子集背包的 dp数组 是boolean，状态转移是 `||`  【416题】
- 完全背包的状态转移是 `+`。由于物品可重复使用，选项 `dp[i-1][w - wt[i-1]]` 变为 `dp[i][w - wt[i-1]]`  【518题】

### 3. base case
第一行、第一列
```
dp[0][..] = ...；
dp[..][0] = ...；
```

**方法：**
1. 画出二维矩阵，结合题意尝试给第一行和第一列赋予实际含义，看他们是否真的是 最小子问题。（对角线同理）
2. 把任一个状态的取值变为 0，看 最小子问题 是什么。
3. base case 的取值结合在题中的实际含义。一般是某一状态的取值为 0 时，根据其余状态不同的取值，决定对应的 base case的取值。

### 4. Return
return 最大子问题对应的dp数组元素即可。
