# 反转单链表：

详见：[labuladong反转单链表](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/)

## 1. **问题分类**：
- 反转整个链表 (leetcode 206)  
- 反转前N个节点  
- 反转其中的一部分 (leetcode 92)

## 2. **递归思路**：
**通过递归来反转单链表，这样可以利用栈后进先出的特性。**  
- 在链表上递归地前进 + 在后序位置写代码 = 从后向前处理链表
- 在链表上递归地前进 + 在前序位置写代码 = 从前向后处理链表

***问题简化：反转其中的一部分 -> 反转前N个节点 -> 反转整个链表***  
1. 反转单链表的前N个节点:   
    用指针指向第N+1个节点，把问题简化成反转长度为N的整个单链表（leetcode 206）  
2. 反转单链表的一部分:（leetcode 92)  
   1. 先递归至要反转的部分，把问题简化成反转前N个节点
   2. 用指针指向第N+1个节点，把问题简化成反转长度为N的整个单链表（leetcode 206)

## 3. **迭代思路**：
***通过迭代来反转单链表，需要多指针+画图+正确处理.next，比较复杂，除非可以化简到反转链表的前K个节点（对每个节点操作相同），否则一般不推荐用***  
**对比迭代和递归反转单链表的前K个节点：**
1. 迭代：
- 传入参数：这K个节点的头和尾（ 尾是第K+1个节点，即反转[头,尾) ），***也就是说想用迭代，就需要先遍历链表获得第K+1个节点的地址***。
- 返回值：返回新的头节点
2. 递归：
- 传入参数：这K个节点的头 和 数值K，**也就是说递归不需要去遍历链表获得第K+1个节点的地址**，但有的题本来就需要第K+1个节点的地址来做别的事，就可以使用迭代。（见25题）
- 返回值：返回新的头节点

## 4. **框架**：
1. 递归框架：可用于反转整个链表、反转前K个节点
```
ListNode reverse(ListNode head) {
    // 1. 前序位置
    // 处理起始情况
    if(head == null || head.next == null) { // if的条件可以改，当前节点为反转部分的最后一个节点时进入此if，作为反转的起始情况
        // 这里可以做一些起始情况需要的操作，如：为其他指针赋值
        return head;  // 反转后的链表的新头节点
    }

    // 2. 递归
    // 参数列表的head.next让我们能在链表上前进
    // 返回值last即为反转后的链表的新头节点
    ListNode last = reverse(head.next);

    // 3. 后序位置
    // 处理指针，反转链表
    head.next.next = head;  // 规定下一个节点的指针指向当前节点
    head.next = ？；  // 规定当前节点的指针指向

    return last;  // 返回值last即为反转后的链表的新头节点
}
```
2. 迭代模版：反转链表的前K个节点
```
ListNode reverse(ListNode start, ListNode end) {
    // 3指针
    ListNode pre, cur, nxt;
    pre = null;  // 保存前一个节点
    cur = start;  // 当前操作的节点
    nxt = start;  // 保存后一个节点

    // 迭代
    while(cur != end) {  // 此处end改为null就是反转整个链表
        nxt = cur.next;  // 注意nxt只能在每次迭代的一开始更新
        cur.next = pre;  // 反转
        pre = cur;  // 更新pre
        cur = nxt;  // 更新cur
    }

    // 返回新的头节点
    return pre;
}
```
