# 反转单链表：

## 1. **问题分类**：
- 反转整个链表  
- 反转前N个节点  
- 反转其中的一部分

## 2. **思路**：
**通过递归来反转单链表，这样可以利用栈后进先出的特性。**  
- 在链表上递归地前进 + 在后序位置写代码 = 从后向前处理链表
- 在链表上递归地前进 + 在前序位置写代码 = 从前向后处理链表

***问题简化：反转其中的一部分 -> 反转前N个节点 -> 反转整个链表***  
1. 反转单链表的前N个节点:   
    用指针指向第N+1个节点，把问题简化成反转长度为N的整个单链表（leetcode 206）  
2. 反转单链表的一部分:  
   1. 先递归至要反转的部分，把问题简化成反转前N个节点
   2. 用指针指向第N+1个节点，把问题简化成反转长度为N的整个单链表（leetcode 206

## 3. **框架**：
```
ListNode reverse(ListNode head) {
    // 1. 前序位置
    // 处理起始情况
    if(head == null || head.next == null) { // if的条件可以改，当前节点为反转部分的最后一个节点时进入此if，作为反转的起始情况
        // 这里可以做一些起始情况需要的操作，如：为其他指针赋值
        return head;
    }

    // 2. 递归
    // 参数列表的head.next让我们能在链表上前进
    // 返回值last即为反转后的链表的新头节点
    ListNode last = reverse(head.next);

    // 3. 后序位置
    // 处理指针，反转链表
    head.next.next = head;  // 规定下一个节点的指针指向当前节点
    head.next = ？；  // 规定当前节点的指针指向

    return last;  // 返回值last即为反转后的链表的新头节点
}
```